#include "Cmm.h"

/* -----------------------------------------------------------------------------
 * Partial Abort TVar primitives
 * -------------------------------------------------------------------------- */

// This must match StgAtomicallyFrame in Closures.h
#define ATOMICALLY_FRAME_FIELDS(w_,p_,info_ptr,p1,p2,code,next,result)  \
    w_ info_ptr,                                                        \
    PROF_HDR_FIELDS(w_,p1,p2)                                           \
    p_ code,                                                            \
    p_ next,                                                            \
    p_ result


INFO_TABLE_RET(stg_partial_atomically_frame, ATOMICALLY_FRAME,
               // layout of the frame, and bind the field names
               ATOMICALLY_FRAME_FIELDS(W_,P_,
                                       info_ptr, p1, p2,
                                       code,
                                       next_invariant,
                                       frame_result))
    return (P_ result) // value returned to the frame
{
    P_ checkpoint;
    gcptr trec, outer, next_invariant, q;

    trec = StgTSO_ptrec(CurrentTSO);

    /* We've got no more invariants to check, try to commit */
    ("ptr" checkpoint) = ccall pa_stmCommitTransaction(MyCapability() "ptr", trec "ptr");

    if(checkpoint == PASTM_SUCCESS){ //Validation succeeded
        StgTSO_ptrec(CurrentTSO) = NO_PTREC;
        frame_result = result;
        return(frame_result);
    }
    if(checkpoint == PASTM_FAIL){ //Validation failed and no checkpoint
		trec = StgTSO_ptrec(CurrentTSO);
		
        ("ptr" trec) = ccall pa_stmStartTransaction(MyCapability() "ptr", trec "ptr");
        StgTSO_ptrec(CurrentTSO) = trec;
        next_invariant = END_INVARIANT_CHECK_QUEUE;

        jump stg_ap_v_fast
            // push the StgAtomicallyFrame again: the code generator is
            // clever enough to only assign the fields that have changed.
            (ATOMICALLY_FRAME_FIELDS(,,info_ptr,p1,p2,
                                     code,next_invariant,frame_result))
            (code);
    }else{//Validation failed, but we have a checkpoint

        P_ k;
        P_ val;

        k = StgPTRecWithK_continuation(checkpoint);
        val = StgPTRecWithK_read_value(checkpoint);

        jump stg_ap_pv_fast  
            // push the StgAtomicallyFrame again: the code generator is
            // clever enough to only assign the fields that have changed.
            (ATOMICALLY_FRAME_FIELDS(,,info_ptr,p1,p2,
                                     code,next_invariant,frame_result))
            (k, val);
    }
}

stg_partial_atomicallyzh (P_ stm)
{
    P_ old_trec;
    P_ new_trec;
    P_ code, next_invariant, frame_result;

    // stmStartTransaction may allocate
    MAYBE_GC_P(stg_partial_atomicallyzh, stm);

    STK_CHK_GEN();

    old_trec = StgTSO_ptrec(CurrentTSO);

    /* Start the memory transcation */
    ("ptr" new_trec) = ccall pa_stmStartTransaction(MyCapability() "ptr", old_trec "ptr");
    StgTSO_ptrec(CurrentTSO) = new_trec;

    code = stm;
    next_invariant = END_INVARIANT_CHECK_QUEUE;
    frame_result = NO_TREC;

    jump stg_ap_v_fast
        (ATOMICALLY_FRAME_FIELDS(,,stg_partial_atomically_frame_info, CCCS, 0,
                                 code,next_invariant,frame_result))
        (stm);
}

stg_partial_eagerFullAbort
{
    W_ frame;
    P_ code; 

    //fully abort -- p_setAtomicallyFrameHelper will unwind the stack to the nearest atomic frame
    //According to StgCmmForeign.hs, SAVE_THREAD_STATE() gets compiled to:
    //tso = CurrentTSO;
    //tso->stackobj->sp = Sp;  --Sp is the register containing the stack pointer
    SAVE_THREAD_STATE();

    //We can use the same C function the partial abort implementation is using
    ccall p_setAtomicallyFrameHelper(MyCapability() "ptr", CurrentTSO "ptr"); 

    /* According to StgCmmForeign.hs:
       tso = CurrentTSO;
       stack = tso->stackobj;
       Sp = stack->sp;
       SpLim = stack->stack + RESERVED_STACK_WORDS;
       HpAlloc = 0;
       --   HpAlloc is assumed to be set to non-zero only by a failed
       --   heap check, see HeapStackCheck.cmm:GC_GENERIC
       p_findAtomicallyFrameHelper will set the tso->stackobj->sp to point to the 
       nearest enclosing atomically frame (there should only be one), so we use
       LOAD_THREAD_STATE() to read the stack pointer out of the TSO and store it in Sp
    */
        
    LOAD_THREAD_STATE();
    frame = Sp;

    //stg_patomically_frame has the same layout as stg_atomically_frame,
    //so just use the macro that they defined for extracting the code
    R1 = StgAtomicallyFrame_code(frame);
    jump stg_ap_v_fast [R1];

}

/*************************************************************************
 * Calling Conventions (comment taken from ghc/compiler/cmm/CmmParse.y)
 * -------------------
 *
 * High-level procedures use the NativeNode calling convention, or the
 * NativeReturn convention if the 'return' keyword is used (see Stack
 * Frames below).
 *
 * Low-level procedures implement their own calling convention, so it can
 * be anything at all.
 *
 * If a low-level procedure implements the NativeNode calling convention,
 * then it can be called by high-level code using an ordinary function
 * call.  In general this is hard to arrange because the calling
 * convention depends on the number of physical registers available for
 * parameter passing, but there are two cases where the calling
 * convention is platform-independent:
 * 
 * - Zero arguments.
 *
 * - One argument of pointer or non-pointer word type; this is always
 *   passed in R1 according to the NativeNode convention.
 * 
 * - Returning a single value; these conventions are fixed and platform
 *   independent.
 *************************************************************************/
//Pass the checkpoint in R1
stg_partial_eagerPartialAbort
{
    P_ k;
    P_ val;

    SAVE_THREAD_STATE(); //see stg_eagerFullAbort for details
    ccall p_setAtomicallyFrameHelper(MyCapability() "ptr", CurrentTSO "ptr");
    LOAD_THREAD_STATE();

    k = StgPTRecWithK_continuation(R1);
    val = StgPTRecWithK_read_value(R1);
    
    jump stg_ap_pv_fast(k, val);

}

stg_partial_readTVarzh (P_ tvar, P_ k)
{
    P_ trec;
    P_ result;
    W_ header;
    
    // Call to stmReadTVar may allocate
    MAYBE_GC_PP (stg_partial_readTVarzh, tvar, k);

    trec = StgTSO_ptrec(CurrentTSO);
    ("ptr" result) = ccall pa_stmReadTVar(MyCapability() "ptr", trec "ptr",
					  tvar "ptr", k "ptr");

    if(result == PASTM_FAIL){
        jump stg_partial_eagerFullAbort []; //full abort
    }
    
    header = StgHeader_info(result);

    if(header == stg_PTREC_WITHK_info){
        jump stg_partial_eagerPartialAbort(result);
    }

    return (result);
}

/*
counterTL2`stg_partial_readTVarzh:
    0x100004510 <+0>:   movq   0x378(%r13), %rax
    0x100004517 <+7>:   cmpq   $0x0, 0x10(%rax)
    0x10000451c <+12>:  je     0x100004587               ; <+119>
    0x10000451e <+14>:  leaq   0x52988b(%rip), %rax      ; g0
    0x100004525 <+21>:  movq   (%rax), %rax
    0x100004528 <+24>:  movq   0x38(%rax), %rax
    0x10000452c <+28>:  leaq   0x52989d(%rip), %rcx      ; large_alloc_lim
    0x100004533 <+35>:  cmpq   (%rcx), %rax
    0x100004536 <+38>:  jae    0x100004587               ; <+119>
    0x100004538 <+40>:  movq   0x368(%r13), %rax
    0x10000453f <+47>:  movq   0x58(%rax), %rax
    0x100004543 <+51>:  leaq   0x236(%rip), %rcx         ; pa_stmReadTVar at CCode.c:133
    0x10000454a <+58>:  leaq   -0x18(%r13), %rdx
    0x10000454e <+62>:  movq   %rdx, %rdi
    0x100004551 <+65>:  movq   %rax, %rsi
    0x100004554 <+68>:  movq   %rbx, %rdx
    0x100004557 <+71>:  movq   %rcx, %rax
    0x10000455a <+74>:  movq   %r14, %rcx
    0x10000455d <+77>:  subq   $0x8, %rsp
    0x100004561 <+81>:  movq   %rax, %rbx
    0x100004564 <+84>:  xorl   %eax, %eax
    0x100004566 <+86>:  callq  *%rbx
->  0x100004568 <+88>:  addq   $0x8, %rsp
    0x10000456c <+92>:  cmpq   0x4a4b45(%rip), %rax      ; (void *)0x00000001005219b0: stg_PA_STM_FAIL_closure
    0x100004573 <+99>:  je     0x10000459f               ; <+143>
    0x100004575 <+101>: movq   (%rax), %rbx
    0x100004578 <+104>: cmpq   0x4a4b49(%rip), %rbx      ; (void *)0x000000010047a500: stg_PTREC_WITHK_info
    0x10000457f <+111>: je     0x1000045a5               ; <+149>
    0x100004581 <+113>: movq   %rax, %rbx
    0x100004584 <+116>: jmpq   *(%rbp)
    0x100004587 <+119>: movq   $0x0, 0x388(%r13)
    0x100004592 <+130>: leaq   -0x89(%rip), %rsi         ; <+0>
    0x100004599 <+137>: jmpq   *0x4a4cd1(%rip)           ; (void *)0x0000000100474348: stg_gc_prim_pp
    0x10000459f <+143>: jmpq   *0x4a4d43(%rip)           ; (void *)0x0000000100004388: stg_partial_eagerFullAbort
    0x1000045a5 <+149>: movq   %rax, %rbx
    0x1000045a8 <+152>: jmpq   *0x4a4d42(%rip)           ; (void *)0x0000000100004448: stg_partial_eagerPartialAbort
    0x1000045ae <+158>: nop 
*/

stg_partial_writeTVarzh (P_ tvar,     /* :: TVar a */
			 P_ new_value /* :: a      */)
{
    W_ trec;

    // Call to stmWriteTVar may allocate
    MAYBE_GC_PP (stg_partial_writeTVarzh, tvar, new_value);

    trec = StgTSO_ptrec(CurrentTSO);
    ccall pa_stmWriteTVar(MyCapability() "ptr", trec "ptr", tvar "ptr",
						  new_value "ptr");
    return (tvar);
}



stg_newTL2TVarzh (P_ init)
{
    W_ tv;

    ALLOC_PRIM_P (SIZEOF_StgTL2TVar, stg_newTL2TVarzh, init);

    tv = Hp - SIZEOF_StgTL2TVar + WDS(1);
    SET_HDR (tv, stg_TL2_TVAR_DIRTY_info, CCCS);

    StgTL2TVar_current_value(tv) = init;
    StgTL2TVar_stamp(tv) = 0;
    StgTL2TVar_lock(tv) = 0;

    return (tv);
}

stg_readTL2TVarIOzh(P_ tvar)
{
    P_ result;
    result = StgTL2TVar_current_value(tvar);
    return(result);
}
